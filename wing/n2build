#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys, getopt, os, os.path, shelve, configparser, hashlib, string, codecs, shutil, datetime, re, zipfile, binascii, time, zlib, signal, subprocess
import socket, threading, base64, json, struct, multiprocessing
from xml.dom import minidom

# 判断必备模块
try:
    import watchdog, watchdog.observers, watchdog.events
except Exception as err:
    print('请先使用 sudo pip install watchdog 安装模块')
    sys.exit(0)

try:
    import lxml
except Exception as err:
    print('请先使用 sudo pip install lxml 安装模块')
    sys.exit(0)

try:
    import openpyxl
except Exception as err:
    print('请先使用 sudo pip install openpyxl 安装模块')
    sys.exit(0)
    
if len(subprocess.getoutput('which npm')) == 0:
    print('请先使用 sudo port install npm 安装node.js环境')
    sys.exit(0)

if len(subprocess.getoutput('which tsc')) == 0:
    print('请先使用 sudo npm install -g typescript 安装Typescript环境')
    sys.exit(0)

if len(subprocess.getoutput('which md5sum')) == 0:
    print('请显示用 sudo port install md5sha1sum 安装必要工具')
    sys.exit(0)

if len(subprocess.getoutput('which wget')) == 0:
    print('请显示用 sudo port install wget 安装必要工具')
    sys.exit(0)
    
cfgdb = None
version = '1.0.0'
HOMEDIR = os.getenv("HOME") + '/'
if not os.path.isdir('.n2~'):
    os.mkdir('.n2~')

def usage():
    print("""
    n2build <-ht> <debug|publish|config|dpack|api file> \n
    -h 帮助
    -t 不启动service
    debug \t 调试模式，默认
    publish \t 发布模式，版本号使用config定义
    dist <debug> \t 打包模式，除了publish的功能，额外会把publish/resource的目录压缩一遍
    clean \t 清空
    config \t 使用引导来配置当前项目
    dpack \t diff-package 增量打包项目版本    
    api file \t 编译 file 文件，产出 api.proto 和 api.ts
    depto <module> \t 使用ResDepto来修改子模块的资源配置文件
    service <list|stop> \t 控制n2build的服务
    skin <preview> \t 皮肤相关的操作 preview:生成皮肤预览[很长时间]
    developer \t 启动开发服务
    genres \t 生成res.json文件
    pubres \t 发布resource到publish中
    checkout \t 切换分支
    debugindex \t 生成debugindex(windows编译出来的index.html中的文件顺序不对的时候需要在mac上生成debug.html)
    """)

# 跨进程锁实现
try:  
    import fcntl  
    LOCK_EX = fcntl.LOCK_EX
except ImportError:  
    # windows平台下没有fcntl模块  
    fcntl = None 
    import win32con  
    import win32file  
    import pywintypes  
    LOCK_EX = win32con.LOCKFILE_EXCLUSIVE_LOCK  
    overlapped = pywintypes.OVERLAPPED()

class GlobalLock:      
    def __init__(self, name):  
        self.name = '.n2~/' + name + '.locker~'
        self.handle = open(self.name, 'w')   
    def acquire(self):
        try:
            if fcntl:
                fcntl.flock(self.handle, LOCK_EX | fcntl.LOCK_NB)
            else:  
                hfile = win32file._get_osfhandle(self.handle.fileno())  
                win32file.LockFileEx(hfile, LOCK_EX, 0, -0x10000, overlapped)
            ret = True
        except Exception as err:
            ret = False
        return ret            
    def release(self):
        try:
            if fcntl:  
                fcntl.flock(self.handle, fcntl.LOCK_UN)  
            else:  
                hfile = win32file._get_osfhandle(self.handle.fileno())  
                win32file.UnlockFileEx(hfile, 0, -0x10000, overlapped)
        except Exception as err:
            pass
    def __del__(self):
        #try:  
        #    self.handle.close()  
        #    os.remove(self.name)  
        #except:  
        #    pass
        pass #会干扰n2build的挂进程svc服务，造成重复启动

# 使用md5散列文件
def hashfile(file):    
    # with open(file, 'rb') as fh:
    #     m = hashlib.md5()
    #     while True:
    #         data = fh.read(8192)
    #         if not data:
    #             break
    #         m.update(data)
    #         return m.hexdigest()
    res = subprocess.getoutput('md5sum ' + file).split(" ")
    return res[0]

def filesize(file):
    st = os.stat(file)
    return st.st_size

# 高性能的简单散列
def simplehashfile(file):
    st = os.stat(file)
    d = ':'.join([str(st.st_size),
                    str(st.st_mtime),
                    str(st.st_ctime)])
    return hashstring(d)

# 简单获取服务相关的临时文件名
_tmpfilecounter = 0;
def tempfilename():
    global _tmpfilecounter
    _tmpfilecounter = _tmpfilecounter + 1
    return str(_tmpfilecounter)

def hashstring(str):
    return hashlib.md5(str.encode("utf-8")).hexdigest()

def isImage(file):
    reximg = re.compile(r'(\.png$)|(\.jpg$)')
    return reximg.search(file) != None

def makeconfig(recfg):
    """使用引导来生成项目的构建配置文件 .n2.cfg"""
    cfg = configparser.SafeConfigParser()
    if recfg:
        cfg.read('.n2.cfg')
    def input(s, k, h):
        if not cfg.has_section(s):
            cfg.add_section(s)
        if cfg.has_option(s, k):
            t = cfg.get(s, k)
        else:
            t = ''
        v = raw_input(h + [' 当前(' + t + ')', ''][not t] + ':') or t
        cfg.set(s, k, v)
    input('app', 'name', '游戏名称')
    input('app', 'icon', 'ICON的路径')
    input('app', 'background', '背景')
    input('app', 'background-color', '背景颜色')
    input('app', 'orientation', '方向 [h]ov/[v]ec')
    input('app', 'resource', '资源的模式 [d]ebug/[p]ublish]')
    input('app', 'version', '版本号')
    input('dev', 'genresdb', '自动生成资源数据 [y]es/[n]o')
    input('dev', 'automerge', '自动合并资源 [y]es/[n]o')
    cfg.write(open('.n2.cfg', 'w'))
    
def checkconfig():    
    """检查决策此次工作的配置"""
    if not os.path.isfile('.n2.cfg'):
        makeconfig(False)
    if 'uuid' not in cfgdb:
        import uuid
        cfgdb['uuid'] = str(uuid.uuid4())
    # 比对是否n2build升版
    if 'bver' not in cfgdb or cfgdb['bver'] != version:
        return True    
    # 比对配置文件是否修改过
    cfghash = hashfile('.n2.cfg')
    if 'cfghash' not in cfgdb or cfgdb['cfghash'] != cfghash:
        cfgdb['cfghash'] = cfghash
        return True
    # 比对n2build是否修改过
    n2bhash = hashfile('n2build')
    if 'n2bhash' not in cfgdb or cfgdb['n2bhash'] != n2bhash:
        cfgdb['n2bhash'] = n2bhash
        return True
    # 比对egretProp是否修改过
    egprj = hashfile('egretProperties.json')
    if 'egprjhash' not in cfgdb or cfgdb['egprjhash'] != egprj:
        cfgdb['egprjhash'] = egprj
        return True
    return False

def egret_makerequire():
    """生成egret需要的文件"""
    # egret3.0.5后，必须准备好native_require.js文件，否则编译报错
    if not os.path.isfile('template/runtime/native_require.js'):
        cnt = string.Template(TPL_NATIVE_REQUIRE).substitute()
        open('template/runtime/native_require.js', 'w').write(cnt)

# 提取app.html中引用独立定义的加载样式
def apphtmlinfo(debug):
    r = {'APPSTYLE':"",
         'APPLAUNCH':"",
         'APPSCRIPT':""}
    # 如果直接返回r则代表不使用app.html
    if not os.path.exists("src/app/app.html"):
        return r
    cfg = configparser.ConfigParser()
    cfg.read('.n2.cfg')
    from lxml import etree
    content = readfile("src/app/app.html")
    # 替换掉assets形式的定义
    if debug == True:
        content = content.replace('assets://', 'resource/assets/')
    else:
        content = content.replace('assets://', 'resource_' + cfg.get('app', 'version') + '/assets/')
    html = etree.HTML(content)
    node = html.find('body').find('style')
    if node != None:
        r['APPSTYLE'] = etree.tostring(node, encoding='utf-8', method='html')
    node = html.find('body').find('div')
    if node != None:
        r['APPLAUNCH'] = etree.tostring(node, encoding='utf-8', method='html')
    node = html.find('body').find('script')
    if node != None:
        r['APPSCRIPT'] = etree.tostring(node, encoding='utf-8', method='html')
    return r

def pdindex():
    """生成调试用的index相关文件"""
    print("生成debug的index.html")
    cfg = configparser.ConfigParser()
    cfg.read('.n2.cfg')
    bkg = cfg.get('app', 'background')
    bkgcolor = cfg.get('app', 'background-color')    
    if bkg.startswith('assets://'):
        bkg = bkg.replace('assets://', 'resource/assets/')
    appinfo = apphtmlinfo(True)
    index = string.Template(TPL_INDEX_DEBUG).substitute({
        'APPNAME': cfg.get('app', 'name'),
        'APPORI': ['portrait', 'landscape'][cfg.get('app', 'orientation') == 'h'],
        'APPANGLE': ['0', '90'][cfg.get('app', 'orientation') == 'h'],
        'APPCONTENT': 'version=0.0.1, debug, verbose' + ['', ', publish'][cfg.get('app', 'resource') == 'p'],
        'BACKGROUND': bkg,
        'BACKGROUNDCOLOR': bkgcolor,
        'APPSTYLE': appinfo['APPSTYLE'],
        'APPLAUNCH': appinfo['APPLAUNCH'],
        'APPSCRIPT': appinfo['APPSCRIPT']
    })
    open('index.html', 'w').write(index)
    # 为了支持插件调试模式，需要描述一下当前项目的信息
    open('src/app/~debug.js', 'w').write(string.Template("""
var app = {};
app.debug = {
    PATH:"${PATH}",
    UUID:"${UUID}",
    CONFIG:${CONFIG},
    BUILDDATE:${BUILDDATE}
};
""").substitute({
    'PATH': os.getcwd(),
    'UUID': cfgdb['uuid'],
    'CONFIG': ['false', 'true'][os.path.exists('~debug.json')],
    'BUILDDATE': int(time.time())
    }))

def prindex():
    # 处理最新的文件
    print("生成release版的index.html")
    if not os.path.isdir('publish'):
        os.mkdir('publish')
    """生成发布版本的index相关文件"""
    cfg = configparser.ConfigParser()
    cfg.read('.n2.cfg')
    bkg = cfg.get('app', 'background')
    bkgcolor = cfg.get('app', 'background-color')
    if bkg.startswith('assets://'):
        if cfg.get('app', 'resource') == 'p':            
            bkg = bkg.replace('assets://', 'resource_' + cfg.get('app', 'version') + '/assets/')
        else:
            bkg = bkg.replace('assets://', 'resource/assets/')
    appinfo = apphtmlinfo(False)
    index = string.Template(TPL_INDEX_RELEASE).safe_substitute({
        'APPNAME': cfg.get('app', 'name'),
        'APPORI': ['portrait', 'landscape'][cfg.get('app', 'orientation') == 'h'],
        'APPANGLE': ['0', '90'][cfg.get('app', 'orientation') == 'h'],
        'APPCONTENT': 'version=' + cfg.get('app', 'version') + ['', ', publish'][cfg.get('app', 'resource') == 'p'],
        'APPVERSION': cfg.get('app', 'version'),
        'APPICON': cfg.get('app', 'icon'),
        'BACKGROUND': bkg,
        'BACKGROUNDCOLOR' : bkgcolor,
        'APPSTYLE': appinfo['APPSTYLE'],
        'APPLAUNCH': appinfo['APPLAUNCH'],
        'APPSCRIPT': appinfo['APPSCRIPT']
    })
    open('publish/index.html', 'w').write(index)

def readfile(file):
    return ''.join(open(file).readlines())

def combinefiles(files, dest):
    cnt = []
    for file in files:
        cnt.append(readfile(file))
    open(dest, 'w').write('\n'.join(cnt))

def prebuildsrc():
    # 处理 tsd 文件
    if not os.path.exists('src/app/~tsc'):
        os.mkdir('src/app/~tsc')
    # 查找所有的tsd, 保存hash到对照表
    tscdb = shelve.open('src/app/~tsc/.db')
    # 处理所有的tsc文件
    files = listfiles('src/app/data', whitelist=[re.compile(r'\.tsc$')])
    for file in files:
        hash = simplehashfile(file)
        key = file.replace('/', '_')
        if key not in tscdb or tscdb[key] != hash:            
            prebuild_tsc(file, key)
            tscdb[key] = hash
    # 处理所有的excel文件
    files = listfiles('src/app/data', whitelist=[re.compile(r'\.xlsx$'),re.compile(r'\.xls$')])
    for file in files:
        if os.path.basename(file).startswith('~'):
            continue
        hash = simplehashfile(file)
        key = file.replace('/', '_')
        if key not in tscdb or tscdb[key] != hash:            
            prebuild_xls(file, key)
            tscdb[key] = hash
    tscdb.close()
    # 合并处理过的所有文件到resource中，形成一个唯一的js
    files = listfiles('src/app/~tsc', whitelist=[re.compile(r'\.js$')])
    combinefiles(files, 'resource/default.data.js')

def prebuild_tsc(file, key):
    print('处理 ' + file)
    shutil.copyfile(file, 'src/app/~tsc/doing.ts')
    # 生成 d.ts 文件
    subprocess.getoutput('tsc -d -t es5 --outDir src/app/~tsc src/app/~tsc/doing.ts')
    shutil.move('src/app/~tsc/doing.d.ts', 'src/app/~tsc/' + key + '.d.ts')
    shutil.move('src/app/~tsc/doing.js', 'src/app/~tsc/' + key + '.js')
    os.unlink('src/app/~tsc/doing.ts')

def prebuild_xls(file, key):
    print('处理 ' + file)
    d = openpyxl.reader.excel.load_workbook(file)
    for e in d.sheetnames:
        prebuild_xls_sheet(d, e, key + '_' + e.lower())

def prebuild_xls_sheet(xls, name, key):
    sh = xls.get_sheet_by_name(name)
    data = {}
    # 第一行是说明，第二行是id会变成property，其他行是数据
    # 查找id位于的colid
    colids = []
    colnames = []
    idxid = None
    for col in range(sh.max_column):
        cell = sh.cell(row=2, column=col+1)
        val = cell.value
        if val != None:
            colids.append(col+1)
            colnames.append(val)
            if val == 'id':
                idxid = col+1
    # 根据第一行的数据类型生成基础的类型定义
    props = []
    for i in range(len(colids)):
        col = colids[i]
        cell = sh.cell(row=3, column=col)
        val = cell.value        
        valtype = 'number'
        if val == None:
            valtype = 'string'
        elif isinstance(val, str) or isinstance(val, unicode):
            valtype = 'string'
        prop = string.Template("""
        get ${NAME}():${TYPE} { return this._obj[${INDEX}]; }
        static ${NAME}Index = ${INDEX};
        """                                   
        ).substitute({
            'NAME':colnames[i],
            'TYPE':valtype,
            'INDEX':i
        })
        props.append(prop)
    # 拼装所有行数据
    rowdatas = []
    rowids = []
    for row in range(3, sh.max_row+1):
        rowid = row - 3
        if idxid != None:
            rowid = sh.cell(row=row, column=idxid).value
        rowdata = []
        for i in range(len(colids)):
            col = colids[i]
            val = sh.cell(row=row, column=col).value
            rowdata.append(val)
        rowids.append(rowid)
        rowdatas.append(rowdata)
    # 输出
    output_xlsdata_tots(name, rowids, rowdatas, props, key)
    
def output_xlsdata_tots(name, ids, datas, props, key):
    # 转换datas到对应的jsobj结构的数据
    jsobjs = []
    for i in range(len(ids)):
        jsobjs.append('"' + str(ids[i]) + '":' + name.lower() + 'Cfgs[' + str(i) + ']')
    # 输出成ts再使用tsc变异成dts和对应js文件，降低性能影响
    cnt = string.Template("""module Data { 
    export var ${NAME}Cfgs:any[] = ${CFGS};
    export var ${NAME}s:any = ${DATA};
    export class ${CLASS} {
    constructor(obj) { this._obj = obj; }
    private _obj:any;
    ${PROPERTIES}
    }
    export function get${CLASS}(id:any):${CLASS} { return new ${CLASS}(${NAME}s[id]); }
    }""").substitute({
        'NAME':name.lower(),
        'CLASS':name[0].upper() + name[1:],
        'CFGS':json.dumps(datas, indent=4),
        'DATA':'{' + ','.join(jsobjs) + '}',
        'PROPERTIES':''.join(props)
    }).encode('utf-8').decode('unicode_escape')
    codecs.open('src/app/~tsc/doing.ts', 'w', 'utf-8').write(cnt)
    # 输出js
    subprocess.getoutput('tsc -d -t es5 --outDir src/app/~tsc src/app/~tsc/doing.ts')
    shutil.move('src/app/~tsc/doing.d.ts', 'src/app/~tsc/' + key + '.d.ts')
    shutil.move('src/app/~tsc/doing.js', 'src/app/~tsc/' + key + '.js')
    os.unlink('src/app/~tsc/doing.ts')

def builddebug(rebuild):
    if rebuild:
        print("重新编译debug版本")
    else:
        print("编译debug版本")
    # 预处理工程代码
    egret_makerequire()
    prebuildsrc()
    # 去除publish引起的egret混乱
    shutil.rmtree('publish', True)
    # 判断使用何种编译
    if rebuild:
        egret_cmd('clean')
        print(egret_cmd('build -e'))
    else:
        print(egret_cmd('build'))

def copydebugtopublish():
    print("拷贝debug文件到publish")
    if not os.path.isdir('publish'):
        os.mkdir('publish')
    shutil.copytree('tools', 'publish/tools')
    shutil.copytree('libs', 'publish/libs')
    shutil.copytree('src/app/~tsc', 'publish/src/app/~tsc')
    shutil.copytree('bin-debug', 'publish/bin-debug')
    shutil.copytree('resource', 'publish/resource')
    shutil.copy('src/app/~debug.js', 'publish/src/app/')
    shutil.copy('index.html', 'publish/')
    shutil.copy('app.json', 'publish/')
    # 判断是否需要合并
    cfg = configparser.ConfigParser()
    cfg.read('.n2.cfg')
    if cfg.get('dev', 'automerge') == 'y':
        print("合并图片")
        processdirs('publish/resource/assets', automergeimages, blacklist=GENRES_BLACKS, depth=2)
        genresdbdirectory('publish')

def lines_between(lines, begin, end):
    ret = []
    match = False
    rexbeg = re.compile(begin)
    rexend = re.compile(end)
    for line in lines:
        if not match:                
            if rexbeg.search(line):
                match = True
            continue
        if rexend.search(line):
            break
        ret.append(line)
    return ret

def lines_replace(lines, begin, end, reps):
    match = False
    rexbeg = re.compile(begin)
    rexend = re.compile(end)
    idxbeg = -1
    idxend = -1
    idx = -1
    for line in lines:
        idx += 1
        if not match:                
            if rexbeg.search(line):                
                match = True
                idxbeg = idx
            continue
        if rexend.search(line):
            idxend = idx
            break
    if idxbeg == -1 or idxend == -1:
        return lines
    l = lines[:idxbeg+1]
    r = lines[idxend:]
    return l + reps + r

def lines_insert(lines, find, inserts):
    rex = re.compile(find)
    idx = -1
    for line in lines:
        idx += 1        
        if rex.search(line):
            break;
    if idx == -1:
        return lines
    l = lines[:idx+1]
    r = lines[idx+1:]
    return l + inserts + r

def safeInt(str, d = 0):
    r = d
    try:
        r = int(str)
    except:
        pass
    return r

# 下载 closure-compiler
def downloadccompiler():
    if not os.path.isfile(".n2~/jscompiler"):
        os.system("wget http://7xlcco.com1.z0.glb.clouddn.com/closure-compiler.jar -O " + ".n2~/jscompiler")

# 下载 euibooster
def downloadeuib():
    if not os.path.isfile(".n2~/euibooster"):
        subprocess.getoutput("wget https://raw.githubusercontent.com/wybosys/n2egret/master/tools/euibooster.js -O " + ".n2~/euibooster.js")
        subprocess.getoutput("wget https://raw.githubusercontent.com/wybosys/n2egret/master/tools/euibooster -O " + ".n2~/euibooster")
        subprocess.getoutput("chmod +x .n2~/euibooster")

PATTERN_HTML_SCRIPT_SRC = re.compile('src="(.+)"')
        
def buildrelease():
    print("编译release版本")
    # 判断是否使用eui
    if os.path.exists('resource/eui_skins'):
        if len(subprocess.getoutput('which euibooster')) == 0:
            print('请先使用 sudo npm install -g cli-eui-new 安装模块')
            sys.exit(0)
        else:
            downloadeuib()
    # 预处理代码
    egret_makerequire()
    prebuildsrc()
    # 重新编译工程
    egret_cmd('build -e')
    # 读取配置
    cfg = configparser.ConfigParser()
    cfg.read('.n2.cfg')
    # 清理binrelease
    if os.path.isdir("bin-release"):
        shutil.rmtree("bin-release")
    print('publish版本' + egret_cmd('publish --compressjson'))
    dir = str(max(map(safeInt, os.listdir('bin-release/web'))))
    # 自动合并release下面的图片
    if cfg.get('dev', 'automerge') == 'y':
        print("自动合并图片")
        processdirs('bin-release/web/' + dir + '/resource/assets/', automergeimages, blacklist=GENRES_BLACKS, depth=2)
        # 因为自动合并图片，需要刷新下bin-release下面的res.json
        genresdbdirectory('bin-release/web/' + dir)
    # 后处理
    print("拷贝release版本到publish")
    shutil.move('bin-release/web/' + dir + '/resource', 'publish/resource')
    shutil.copyfile('bin-release/web/' + dir + '/main.min.js', 'publish/main.min.js')
    # 压缩eui
    if os.path.exists('resource/eui_skins'):
        print('编译 eui-skins')
        shutil.copyfile('publish/resource/default.thm.json', 'publish/resource/default.thm')
        os.system('.n2~/euibooster ' + os.getcwd() + ' publish')
    files = []
    # 提取标准打包出来的数据
    html = open('bin-release/web/' + dir + '/index.html').readlines()
    libfiles = lines_between(html, '<!--modules_files_start-->', '<!--modules_files_end-->')
    # 打包基础的库文件
    libscnt = []
    for file in libfiles:
        file = PATTERN_HTML_SCRIPT_SRC.findall(file)[0]
        libscnt.append(readfile(file))
    open("publish/engine.min.js", "w").write('\n'.join(libscnt))
    files.append('<script src="engine.min.js?v=' + cfg.get('app', 'version') + '"></script>\n')
    # 打包进自定义生成的数据文件
    if os.path.isdir("src/app/~tsc"):
        downloadccompiler()
        # 保存一下原始的
        shutil.move('publish/resource/default.data.js', '.n2~/default.data.js')
        # 使用cc来压缩js
        os.system("java -jar .n2~/jscompiler --charset utf8 --language_out ECMASCRIPT5 --js .n2~/default.data.js --js_output_file publish/resource/default.data.js")
    # 需要给js上加上版本标记
    files.append('<script src="main.min.js?v=' + cfg.get('app', 'version') + '"></script>\n')
    html = string.Template(''.join(open('publish/index.html').readlines()))
    open('publish/index.html', 'w').write(html.safe_substitute({
        'FILESLIST': ''.join(files)
    }))

# 数据库
def db_get(file, val={}):
    s = shelve.open(file)
    for e in s.keys():
        val[e] = s[e]
    return val

def db_set(obj, file):
    s = shelve.open(file)
    for e in obj.keys():
        s[e] = obj[e]
    s.close()

# 打包资源文件
def distfile(q, sem, file, func, db, prg):
    idx = prg[0]
    sum = prg[1]
    key = hashstring(file)
    if key in db:
        # 如果大小不同，再比对hash，加速
        hash = hashfile(file)
        if hash == db[key]:
            print('COPY %d/%d' %(idx,sum), file)
            shutil.copyfile('.n2~/dist/' + key, file)
            sem.release()
            return
        db[key] = hash
        oldsz = filesize(file)
        func(file)
        newsz = float(filesize(file))
        print('RECOMPRESS %d/%d' %(idx,sum), file, '%d%%' %(newsz/oldsz*100), '%dK' %(newsz/1024))
        shutil.copyfile(file, '.n2~/dist/' + key)
        sem.release()
        return
    hash = hashfile(file)
    db[key] = hash
    oldsz = filesize(file)
    func(file)
    newsz = float(filesize(file))
    print('COMPRESS %d/%d' %(idx,sum), file, '%d%%' %(newsz/oldsz*100), '%dK' %(newsz/1024))
    shutil.copyfile(file, '.n2~/dist/' + key)
    sem.release()

def distpng(file):    
    os.system("pngquant --ext .png --force --speed 1 " + file)

def distjpg(file):
    os.system("jpegoptim -m30 " + file)
    
def distresources():
    # .n2~ 中建立一个数据库，保存历史中的文件优化信息，并保存文件版本，该版本会当目标文件变化时更新，因为.n2~会随着n2build clean清除，所以一定程度上可以忽视image文件大量积压问题
    db = db_get('.n2~/dist.db', multiprocessing.Manager().dict())
    if not os.path.isdir('.n2~/dist'):
        os.mkdir('.n2~/dist')
    # 针对png和jpg分别处理
    pngs = listfiles("publish/resource", whitelist=[re.compile(r'(\.png$)')])
    jpgs = listfiles("publish/resource", whitelist=[re.compile(r'(\.jpg$)')])
    idx = 0
    sum = len(pngs) + len(jpgs)
    # 多进程处理
    sem = multiprocessing.Semaphore(8)
    for png in pngs:
        sem.acquire()
        idx += 1
        q = multiprocessing.Queue()
        p = multiprocessing.Process(target=distfile, args=(q, sem, png, distpng, db, (idx,sum)))
        p.start()
    for jpg in jpgs:
        sem.acquire()
        idx += 1
        # 启动进程
        q = multiprocessing.Queue()
        p = multiprocessing.Process(target=distfile, args=(q, sem, jpg, distjpg, db, (idx,sum)))
        p.start()
    # 额外做一下等待
    time.sleep(10)
    db_set(db, '.n2~/dist.db')
        
def explorer(path):
    subprocess.getstatusoutput("terminal-notifier -title N2BUILD -sound default -message 发布成功 " + "-execute \"open " + path + "\"")

def egret_cmd(cmd):
    s, ot = subprocess.getstatusoutput('egret ' + cmd)
    return ot

SRV_DEBUG_RUN = True
WS_MAGIC_STRING = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'
WS_HANDSHAKE_STRING = "HTTP/1.1 101 Switching Protocols\r\n" \
                      "Upgrade:websocket\r\n" \
                      "Connection: Upgrade\r\n" \
                      "Sec-WebSocket-Accept: {1}\r\n" \
                      "WebSocket-Location: ws://{2}/chat\r\n" \
                      "WebSocket-Protocol:chat\r\n\r\n"

class WS_SERVICE(threading.Thread):
    def __init__(self, connection):
        threading.Thread.__init__(self)
        self.con = connection
        self.workers = {}
    def run(self):
        while True:
            try:
                rec = self.recv_data(9216)
                if type(rec) == str:
                    m = json.loads(unicode(rec, "utf-8"))
                    cmd = m[u'cmd']
                    if self.workers.has_key(cmd):
                        worker = self.workers[cmd]
                        if worker(m):
                            # 发送成功
                            m['rsp'] = True
                            self.send_data(json.dumps(m))
                    else:
                        print('服务器不支持该命令 ' + cmd)
            except Exception as err:
                print('处理收到的数据失败', err)
        self.con.close()
    def work(self, cmd, worker):
        self.workers[cmd] = worker
    def recv_data(self, num):
        try:
            all_data = self.con.recv(num)
            if not len(all_data):
                return False
        except:
            return False
        else:
            code_len = ord(all_data[1]) & 127
            if code_len == 126:
                masks = all_data[4:8]
                data = all_data[8:]
            elif code_len == 127:
                masks = all_data[10:14]
                data = all_data[14:]
            else:
                masks = all_data[2:6]
                data = all_data[6:]
            raw_str = ""
            i = 0
            for d in data:
                raw_str += chr(ord(d) ^ ord(masks[i % 4]))
                i += 1
            return raw_str  
    def send_data(self, data):
        if data:
            data = str(data)
        else:
            return False
        token = "\x81"
        length = len(data)
        if length < 126:
            token += struct.pack("B", length)
        elif length <= 0xFFFF:
            token += struct.pack("!BH", 126, length)
        else:
            token += struct.pack("!BQ", 127, length)
        data = '%s%s' % (token, data)
        self.con.send(data)
        return True

def ws_handshake(con):
    headers = {}
    shake = con.recv(1024)    
    if not len(shake):
        return False
    header, data = shake.split('\r\n\r\n', 1)
    for line in header.split('\r\n')[1:]:
        key, val = line.split(': ', 1)
        headers[key] = val      
    if 'Sec-WebSocket-Key' not in headers:
        return False
    sec_key = headers['Sec-WebSocket-Key']
    res_key = base64.b64encode(hashlib.sha1(sec_key + WS_MAGIC_STRING).digest())  
    str_handshake = WS_HANDSHAKE_STRING.replace('{1}', res_key).replace('{2}', 'localhost:59000')
    con.send(str_handshake)
    return True

# 运行守护进程
def start_deamon():
    pid = os.fork()
    if pid != 0:
        open(HOMEDIR + "/.n2.builder.deamons", 'a').write(str(pid) + '\n')
    return pid == 0

def stop_deamons():
    if not os.path.exists(HOMEDIR + "/.n2.builder.deamons"):
        return
    for pid in get_deamons():
        try:
            os.kill(pid, signal.SIGKILL)
        except:
            pass
    os.unlink(HOMEDIR + "/.n2.builder.deamons")

def get_deamons():
    r = []
    if not os.path.exists(HOMEDIR + "/.n2.builder.deamons"):
        return []
    for line in open(HOMEDIR + "/.n2.builder.deamons", 'r').readlines():
        try:
            r.append(int(line))
        except:
            pass
    return r

# 启动标准的ws服务
def wswrk_launch(port, wrkidr, wrkfun):
    # 如果已经运行，则跳过
    lck = GlobalLock(wrkidr.replace(':', '_'))
    if lck.acquire() == False:
        return
    lck.release()
    # 子进程
    if start_deamon():
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind(('localhost', int(port)))
            sock.listen(1000)
        except Exception as err:
            print(err)
            return
        lck = GlobalLock(wrkidr.replace(':', '_'))
        lck.acquire()
        while SRV_DEBUG_RUN:
            connector, addr = sock.accept()
            if addr[0] != '127.0.0.1':
                connector.close()
                continue
            if ws_handshake(connector):
                try:
                    svc = WS_SERVICE(connector)
                    svc.work(wrkidr, wrkfun)
                    svc.start()
                except:
                    connector.close()
        lck.release()
                    
# 监听文件变动
def watchfilesystem(name, path, handler):
    lck = GlobalLock(name)
    if lck.acquire() == False:
        return False
    lck.release()
    # 创建工作进程
    #wfs_worker(name, path, handler)
    #return
    if start_deamon():
        wfs_worker(name, path, handler)
    return True
        
def wfs_worker(name, path, handler):
    lck = GlobalLock(name)
    lck.acquire()
    try:
        obs = watchdog.observers.Observer()
        obs.schedule(handler, path, recursive=True)
        obs.start()
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            obs.stop()
        obs.join()
    except Exception as err:
        print(err)
    lck.release()

# ----------------------------------- 控制 wing 的状态
def egret_wing_usefile(file, dir):    
    hex = """\n\x0b\x01\x1blayoutDefault\n\x01;MainView.WorkSpace.Programmer\x06\x8e${SIZE}<BoxElement width="1886" height="955" id="6">\n  <BoxElement isVertical="true" width="272" height="955" id="2">\n    <TabGroup selectedIndex="0" width="272" height="478" id="0">\n      <TabPanel content="packagePanel"/>\n    </TabGroup>\n    <TabGroup selectedIndex="0" width="272" height="478" id="1">\n      <TabPanel content="outlinePanel"/>\n    </TabGroup>\n  </BoxElement>\n  <BoxElement isVertical="true" width="1615" height="955" id="5">\n    <Document width="1615" height="955" id="3">\n      <TabGroup selectedIndex="0" width="1615" height="955" id="7">\n        <TabPanel path="${FILE}"/>\n      </TabGroup>\n    </Document>\n    <TabGroup selectedIndex="0" minimized="true" id="4">\n      <TabPanel content="consolePanel"/>\n      <TabPanel content="progressPanel"/>\n      <TabPanel content="searchResultPanel"/>\n      <TabPanel content="errorPanel"/>\n    </TabGroup>\n  </BoxElement>\n</BoxElement>\x01\x0fcurrent\n\x01\tname\x06\x02\ttype\x06\x0fdefault\x01\x01"""
    layout = HOMEDIR + "Library/Application Support/EgretWing/Local Store/layout.amf"    
    cnt = string.Template(hex).substitute({
        'SIZE':chr(len(dir) + (len(file) + 1)*2),
        'FILE':dir + '/' + file
        })
    open(layout, 'w').write(egret_compress(cnt))

def egret_wing_openwing(file, dir, fun = None):
    layout = HOMEDIR + "Library/Application Support/EgretWing/Local Store/layout.amf"
    # 保存老的
    shutil.copyfile(layout, layout + ".bak")
    egret_wing_usefile(file, dir)
    # 打开wing
    app = subprocess.Popen("/Applications/EgretWing.app/Contents/MacOS/EgretWing", stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if fun != None:
        # 需要等待20s当wing启动正常后再处理
        time.sleep(20)
        fun()
        # 关闭
        app.kill()
    # 退出后恢复
    app.wait()
    shutil.move(layout + ".bak", layout)

def egret_wing_captureskin(file, dir, to):
    try:
        import pyscreeze
    except:
        print('请使用 sudo pip install pyscreeze 安装模块')
        sys.exit(0)
    print("即将生成 " + file + " 的预览")
    def captureskin():
        img = pyscreeze.screenshot(region=(700, 160, 780, 900))
        img.save(to)
    egret_wing_openwing(file, dir, captureskin)

def preview_skins():
    skins = listfiles('resource/eui_skins/app', whitelist=[re.compile(r'\.exml$')])
    if not os.path.exists('preview'):
        os.mkdir('preview')
    dir = os.getcwd()
    for skin in skins:
        name = skin[23:].replace('/', '_') + '.jpg'
        egret_wing_captureskin(skin, dir, 'preview/' + name)

# ----------------------------------- 生成子资源模块 ---------------------------
def svc_subresmaker():
    suc = watchfilesystem("resmaker", "resource/assets", hdl_resmaker())
    # 每次第一次打开，自动重建一下索引
    if suc:
        resmaker_rebuild()
        
class hdl_resmaker(watchdog.events.FileSystemEventHandler):
    def getinfo(self, e):
        p = e.src_path
        if os.path.isdir(p):
            return None
        res = re.compile(r'resource/assets/(0-9a-zA-Z]+)/(.+)').findall(p)
        if len(res) == 0:
            return None
        res = res[0]
        mod = res[0]
        path = mod + '/' + res[1]
        return (mod, path)
    def rebuild(self, e):
        info = self.getinfo(e)
        if info != None:
            resmaker_buildmod('resource/assets/' + info[0])
    def on_created(self, e):        
        self.rebuild(e)
    def on_deleted(self, e):
        self.rebuild(e)
    def on_moved(self, e):
        self.rebuild(e)
    
def resmaker_rebuild():
    # 刷新资源的索引，默认 resource 下面每一个文件夹都代表一个res-module，里面按照jsonobj保存资源的name-path
    for each in listdirs("resource/assets", depth=1):
        resmaker_buildmod(each)

RESMAKER_BLACKS = [
    re.compile(r'module\.res\.json$'),
    re.compile(r'\.swf$'),
    re.compile(r'\.fla$'),
    re.compile(r'^\.')
];

def resmaker_buildmod(dir):
    files = listfiles(dir, blacklist=RESMAKER_BLACKS)
    # 做成keyvalue
    dict = {}
    for file in files:
        fns = os.path.splitext(os.path.basename(file))
        dict[fns[0] + fns[1]] = {'p':file.replace('resource/assets/', '')}
    # 使用增量的方式可以避免通过工具设置的其它参数被冲掉
    resf = dir + '/module.res.json'
    if os.path.exists(resf):
        try:
            predict = json.loads(''.join(open(resf).readlines()))
        except:
            print('处理 ' + resf + ' 失败')
        for k in dict:
            if k in predict:
                v = predict[k]
                dict[k] = v
    fp = open(resf, 'w')
    fp.write(json.dumps(dict, indent=4))
    fp.close()

def egret_compress(c):
    r = zlib.compress(c)
    a = list(r)
    a[1] = chr(0xda)    
    return ''.join(a)

def egret_decompress(c):
    return zlib.decompress(c)

def egret_compressfile(file, to):
    cnt = ''.join(open(file).readlines())
    open(to, 'w').write(egret_compress(cnt))

def egret_decompressfile(file, to):
    cnt = ''.join(open(file).readlines())
    open(to, 'w').write(egret_decompress(cnt))

def resmaker_rundepto(submod):
    # 根据module.res.json生成resource.json文件
    dir = "resource/assets/" + submod + "/"
    modj = dir + "module.res.json"
    deptoj = dir + "~module.depto.json"
    deptodat = HOMEDIR + "Library/Application Support/ResDepot/Local Store/data.dat"
    # 转换module的结构
    obj = json.loads(''.join(open(modj, 'r').readlines()))
    pks = []
    for k in obj:
        if isImage(k) == False:
            continue
        # 只处理图片
        d = {
            "name":k,
            "type":"image",
            "url":obj[k]['p']
        }
        if 'g' in obj[k]:
            d["scale9grid"] = obj[k]['g']
        pks.append(d)
    pks = {"groups":[], "resources":pks}
    open(deptoj, 'w').write(json.dumps(pks))
    # 生成
    tpl = """\n\x0b\x01\x13rootPaths\t\x03\x01\n\x01\x11rootPath\x06Y${AST}\x07url\x06\x81\x0b${CNT}\x01\x19opendConfigs\t\x03\x01\x06\x08\x19recentlyOpen\t\x03\x01\x06\x08\x1bcurrentConfig\x06\x08\x0fpreview\x03\x01"""
    # 先保护原始的
    if os.path.exists(deptodat):
        shutil.move(deptodat, deptodat + '.bak')
    # 生成新的
    cnt = string.Template(tpl).substitute({
        'CNT':os.getcwd() + "/" + deptoj,
        'AST':os.getcwd() + "/" + "resource/assets/"
    })
    open(deptodat, 'wb').write(egret_compress(cnt))
    # 启动resdepto
    s, ot = subprocess.getstatusoutput("/Applications/ResDepot.app/Contents/MacOS/ResDepot")
    # 读取临时的res.json提取9点
    resobj = json.loads(''.join(open(deptoj, 'r').readlines()))
    ress = resobj['resources']
    for v in ress:
        nm = v['name']
        if 'scale9grid' in v:
            obj[nm]['g'] = v['scale9grid']
        elif 'g' in obj[nm]:
            obj[nm].pop('g')
    # 写回配置
    open(modj, 'w').write(json.dumps(obj, indent=4))
    os.unlink(deptoj)
    # 恢复原来的
    if os.path.exists(deptodat + '.bak'):
        shutil.move(deptodat + '.bak', deptodat)

# ---------------------------------------- 生成资源数据表 ----------------------
def svc_genresdb():
    suc = watchfilesystem("genresdb", "resource/assets", hdl_genresdb())
    # 如过监听成功，则为第一次打开，保险期间自动刷一次res
    if suc:
        genresdb()

class hdl_genresdb(watchdog.events.FileSystemEventHandler):
    def on_created(self, e):
        p = e.src_path
        if not ismatchs(p, GENRES_BLACKS):            
            genresdb()
    def on_deleted(self, e):
        p = e.src_path
        if not ismatchs(p, GENRES_BLACKS):            
            genresdb()
    def on_moved(self, e):
        p = e.src_path
        if not ismatchs(p, GENRES_BLACKS):            
            genresdb()

# 拆分成文件名和文件后缀
def split_filename(file):
    sp = os.path.splitext(os.path.basename(file))
    ext = sp[1]
    if '.' in ext:
        return [sp[0], ext[1:]]    
    return [sp[0], '']

def egretfileinfo(file):
    dir = os.path.dirname(file)
    sp = split_filename(file)
    name = sp[0] # + '_' + sp[1], 不使用 _ 来分割
    r = {}
    if '_automerged_' in name:
        if sp[1] == 'png':
            return None
        name = sp[0] + '_json';
        type = 'sheet';
        # 读取subkeys
        jsobj = json.loads(readfile(file))
        frmobjs = jsobj['frames']
        r['subkeys'] = ','.join(frmobjs.keys())
    elif sp[1] == 'png':
        if os.path.isfile(dir + '/' + sp[0] + '.json') or os.path.isfile(dir + '/' + sp[0] + '.fnt'):
            name = sp[0] + '_png'
        type = 'image'
    elif sp[1] == 'jpg':
        type = 'image'        
    elif sp[1] == 'json':
        # 如过同时存在 file_png 和 file_json 的队列，则认为是特殊资源，需要保持命名
        if os.path.isfile(dir + '/' + sp[0] + '.png'):
            name = sp[0] + '_json'
        type = 'json'
    elif sp[1] == 'ttf':
        name = sp[0] + '_ttf'
        type = 'font'        
    elif sp[1] == 'fnt':
        name = sp[0] + '_fnt'
        type = 'font'
    else:
        type = 'bin'
    r['name'] = name;
    r['type'] = type;
    return r

GENRES_BLACKS = RESMAKER_BLACKS + [re.compile('\.d/|\.d$')]

def genresdb():
    # 遍历所有的子文件，找出png\jpg\json，生成default.res.json文件并生成对应的group
    jsobj = {'groups':[], 'resources':[]}
    # 第一级的资源为不加入group中的
    for file in listfiles('resource/assets', blacklist=GENRES_BLACKS, depth=1):
        info = egretfileinfo(file)
        if info == None:
            continue
        info['url'] = file.replace('resource/', '')
        jsobj['resources'].append(info)
    # 处理其他级别的目录
    def proc(path, dirname):
        keys = []
        parts = []
        for file in listfiles(path, blacklist=GENRES_BLACKS, depth=1):
            info = egretfileinfo(file)
            if info == None:
                continue
            info['url'] = file.replace('resource/', '')
            keys.append(info['name'])
            parts.append(info)
        jsobj['groups'].append({'name':dirname.replace('/', '_'),
                                'keys':','.join(keys)})
        jsobj['resources'] += parts
    processdirs("resource/assets", proc, blacklist=GENRES_BLACKS, depth=2)
    open('resource/default.res.json', 'w').write(json.dumps(jsobj, indent=4))

def genresdbdirectory(dir):
    jsobj = {'groups':[], 'resources':[]}
    for file in listfiles(dir + '/resource/assets', blacklist=GENRES_BLACKS, depth=1):
        info = egretfileinfo(file)
        if info == None:
            continue
        info['url'] = file.replace(dir + '/resource/', '')
        jsobj['resources'].append(info)
    def proc(path, dirname):
        keys = []
        parts = []
        for file in listfiles(path, blacklist=GENRES_BLACKS, depth=1):
            info = egretfileinfo(file)
            if info == None:
                continue
            info['url'] = file.replace(dir + '/resource/', '')
            keys.append(info['name'])
            parts.append(info)
        jsobj['groups'].append({'name':dirname.replace('/', '_'),
                                'keys':','.join(keys)})
        jsobj['resources'] += parts
    processdirs(dir + "/resource/assets", proc, blacklist=GENRES_BLACKS, depth=2)
    open(dir + '/resource/default.res.json', 'w').write(json.dumps(jsobj, indent=4))

def pubres():
    cfg = configparser.ConfigParser()
    cfg.read('.n2.cfg')
    shutil.rmtree('publish', True)
    print('copy资源')
    shutil.copytree('resource', 'publish/resource')
    if cfg.get('dev', 'automerge') == 'y':
        print('自动合并资源')
        processdirs('publish/resource/assets', automergeimages, blacklist=GENRES_BLACKS, depth=2)
        genresdbdirectory('publish')

# ---------------------------------------- 维护Skin和实现类之间的关系 --------------
def skinimpl_regen():
    # 如过不存在skin文件夹，跳过
    if not os.path.isdir('resource/eui_skins/app'):
        return
    # 列出所有的skin
    skins = listfiles('resource/eui_skins/app', whitelist=[re.compile(r'\.exml$')])
    # 生成对应的实现文件
    thms = [
        '"eui.ButtonU":"resource/eui_skins/wgt/ButtonSkin.exml"',
        '"eui.CheckBoxU":"resource/eui_skins/wgt/CheckBoxSkin.exml"',
        '"eui.ToggleSwitchU":"resource/eui_skins/wgt/ToggleSwitchSkin.exml"',
        '"eui.TextInputU":"resource/eui_skins/wgt/TextInputSkin.exml"',
        '"eui.ScrollerU":"resource/eui_skins/wgt/ScrollerSkin.exml"',
        '"eui.ItemRendererU":"resource/eui_skins/wgt/ItemRendererSkin.exml"',
        '"eui.VScrollBar":"resource/eui_skins/wgt/VScrollBarSkin.exml"',
        '"eui.HScrollBar":"resource/eui_skins/wgt/HScrollBarSkin.exml"',
        '"eui.ProgressBarU":"resource/eui_skins/wgt/ProgressBarSkin.exml"'
    ]
    for skin in skins:
       cls = skinimpl_genfile(skin)
       thms.append('"' + cls + '":"' + skin + '"')
    # 重新生成default.thm.json
    open('resource/default.thm.json', 'w').write(string.Template("""{
    "autoGenerateExmlsList": true,
    "exmls": [],
    "skins": {${SKINS}}
}""").substitute({
    'SKINS': ',\n'.join(thms)
    }))

def skinimpl_genfile(file):
    # 解析xml
    xml = minidom.parse(file)
    root = xml.documentElement
    # 查找所有的id
    nodes = dom_getElementsByAttributeName(root, 'id')
    slots = dom_getAttributesByName(root, 'slots')
    # 提取变量
    props = []
    for node in nodes:
        id = node.getAttribute('id')
        ns = node.namespaceURI
        nm = node.nodeName
        cls = nm[nm.index(':')+1:]
        e = nm[:nm.index(':')]
        if e != 'e':
            cls = ns.replace('*', cls)
        else:
            cls = 'eui.' + cls
        props.append('        ' + id + ':' + cls + ';\n')
    # 排序
    slots.sort()
    props.sort()
    # 处理对应的实现文件
    # 提取名称
    srcls = file[file.index('resource/'):].replace('resource/eui_skins/', '').replace('Skin.exml', '')
    srcfn = 'src/' + srcls + '.ts'
    # 如果不存在，则需要根据模版生成新的文件
    if not os.path.exists(srcfn):
        # modname
        mdnm = os.path.dirname(srcls).replace('/', '.')
        # 创建目录
        dir = os.path.dirname(srcfn)
        if not os.path.exists(dir):
            os.makedirs(dir)
        cnt = string.Template("""
module ${MODULE} {\n
    interface I${CLASS}
    {
        //slot {
        //slot }
    }

    export class ${CLASS}
    extends eui.SpriteU
    implements I${CLASS}
    {
        //skin {
        //skin }
    }
\n}
""").substitute({
    'MODULE': mdnm,
    'CLASS': os.path.basename(srcls)
})
        try:
            open(srcfn, 'w').write(cnt)
        except:
            print(srcfn + "保存处理过的xml失败")
            raise
    # 生成interface需要的函数
    funs = set()
    for slot in slots:
        for each in slot.split(';'):
            if each == '':
                continue
            a = each.split('=>')
            if len(a) != 2:
                continue
            funs.add('        _' + a[1] + '(s?:nn.Slot);\n')            
    # 读取文件，插入对应的变量
    lines = open(srcfn).readlines()
    lines = lines_replace(lines, '//skin {', '//skin }', props)
    lines = lines_replace(lines, '//slot {', '//slot }', list(funs))
    codecs.open(srcfn, 'w', 'utf-8').write(''.join(lines))
    # 返回类名
    return srcls.replace('/', '.')

def dom_getElementsByAttributeName(node, name, r=None):
    if r == None:
        r = []
    for each in node.childNodes:
        if each.nodeType != each.ELEMENT_NODE:
            continue
        if each.hasAttribute(name):
            r.append(each)
        dom_getElementsByAttributeName(each, name, r)
    return r

def dom_getAttributesByName(node, name, r=None):
    if r == None:
        r = []
    if node.nodeType != node.ELEMENT_NODE:
        return r
    if node.hasAttribute(name):
        r.append(node.getAttribute(name))
    for each in node.childNodes:
        dom_getAttributesByName(each, name, r)
    return r

def svc_genskinimpls():
    if not os.path.isdir("resource/eui_skins/app"):
        return
    suc = watchfilesystem("genskinimpls", "resource/eui_skins/app", hdl_genskinimpls())
    if suc:
        skinimpl_regen()

class hdl_genskinimpls(watchdog.events.FileSystemEventHandler):
    def on_modified(self, e):
        p = e.src_path
        if not p.endswith('.exml'):
            return
        skinimpl_genfile(p)
    def on_created(self, e):
        p = e.src_path
        if not p.endswith('.exml'):
            return
        cls = skinimpl_genfile(p)
        exml = p[p.index('resource/'):]
        obj = json.loads(readfile('resource/default.thm.json'))
        if cls not in obj['skins']:
            obj['skins'][cls] = exml
        open('resource/default.thm.json', 'w').write(json.dumps(obj))
    def on_deleted(self, e):
        p = e.src_path
        if not p.endswith('.exml'):
            return
        srcls = p[p.index('resource/'):].replace('resource/eui_skins/', '').replace('Skin.exml', '')
        cls = srcls.replace('/', '.')
        obj = json.loads(readfile('resource/default.thm.json'))
        if cls in obj['skins']:
            obj['skins'].pop(cls)
        open('resource/default.thm.json', 'w').write(json.dumps(obj))
    def on_moved(self, e):
        p = e.dest_path
        if not ismatchs(p, GENRES_BLACKS):            
            genresdb()

# ---------------------------------------- 开发专用服务对应于 Developer.ts --------
def svc_developer():
    try:
        import wx
    except Exception as err:
        print('请先使用 sudo pip install wxPython 安装模块')
        sys.exit(0)
    try:
        import Image
    except Exception as err:
        print('请先使用 sudo pip install PIL 安装模块')
        sys.exit(0)
    # 临时工作的文件夹
    if not os.path.isdir('.n2~/developer'):
        os.mkdir('.n2~/developer')
    # 释放辅助脚本
    open('.n2~/file_dlg_open.py', 'w').write("""
import wx
app = wx.App(None)
style = wx.FD_OPEN | wx.FD_FILE_MUST_EXIST
dialog = wx.FileDialog(None, 'Open File', style=style)
if dialog.ShowModal() == wx.ID_OK:
    path = dialog.GetPath()
else:
    path = ''
dialog.Destroy()
print(path)
""")
    open('.n2~/file_dlg_save.py', 'w').write("""
import wx
app = wx.App(None)
style = wx.FD_SAVE
dialog = wx.FileDialog(None, 'Save To', style=style)
if dialog.ShowModal() == wx.ID_OK:
    path = dialog.GetPath()
else:
    path = ''
dialog.Destroy()
print(path)
""")
    open('.n2~/file_dlg_dir.py', 'w').write("""
import wx
app = wx.App(None)
dialog = wx.DirDialog(None)
if dialog.ShowModal() == wx.ID_OK:
    path = dialog.GetPath()
else:
    path = ''
dialog.Destroy()
print(path)
""")
    # wswrk_launch('59000', chrome-devtools) 
    wswrk_launch('59001', WSWRK_DEVELOPER, wswrk_developer)

# ---------------------------------------- 生成debug.html --------------------------------
def debugindex():
    content = readfile('index.html')
    content = re.sub('<!--[^-->]+-->', '', content)
    open('debug.html', 'w').write(content)
    
# ---------------------------------------- Main --------------------------------
def main():
    # 处理主命令
    try:
        opts, args = getopt.getopt(sys.argv[1:], "-t", [''])
    except getopt.GetoptError:
        usage()
        return    
    if 'service' in args:
        cmd = args[args.index('service') + 1]
        if cmd == 'list':
            print(get_deamons())
            return
        elif cmd == 'stop':
            stop_deamons()
            return
    elif 'developer' in args:
        svc_developer()
        return
    elif 'genres' in args:
        genresdb()
        return
    elif 'pubres' in args:
        pubres()
        return
    elif 'distres' in args:
        pubres()
        distresources()
        return
    elif 'checkout' in args:
        stop_deamons()
        os.system("git checkout " + args[args.index('checkout') + 1])
        return
    elif 'debugindex' in args:
        debugindex()
        return
    if 'null' in args:
        return
    # 尝试运行持久任务
    if ('-t', '') not in opts:
        svc_genresdb()
        svc_genskinimpls()
        # svc_subresmaker()
    else:
        # 需要直接运行服务的内容
        genresdb()
        skinimpl_regen()
    if 'config' in args:
        makeconfig(True)
        return
    if 'api' in args:
        buildapi(args[args.index('api') + 1])
        return
    if 'dpack' in args:
        dpack()
        return
    if 'clean' in args:
        clean();
        return
    if 'depto' in args:
        resmaker_rundepto(args[args.index('depto') + 1])
        return
    if 'skin' in args:
        cmd = args[args.index('skin') + 1]
        if cmd == 'preview':
            print('将会花费较长时间，请耐心等待')
            preview_skins()
        return
    # 是否需要重新生成index
    RepDindex = checkconfig()
    if 'publish' in args:
        # 去除publish引起的egret自动判断文件混乱
        shutil.rmtree('publish', True)
        prindex()
        buildrelease()
        # 重新生成resource的目录
        cfg = configparser.ConfigParser()
        cfg.read('.n2.cfg')
        resdir = 'publish/resource'
        if cfg.get('app', 'resource') == 'p':
            resdir = resdir + '_' + cfg.get('app', 'version')
            shutil.move('publish/resource', resdir)
        explorer('publish')
    elif 'dist' in args:
        debug = 'debug' in args
        # 去除publish引起的egret自动判断文件混乱
        shutil.rmtree('publish', True)
        if debug:
            pdindex()
            builddebug(True)
            copydebugtopublish()
            distresources()
        else:
            prindex()
            buildrelease()
            distresources()
            # 重新生成resource的目录
            cfg = configparser.ConfigParser()
            cfg.read('.n2.cfg')
            resdir = 'publish/resource'
            if cfg.get('app', 'resource') == 'p':
                resdir = resdir + '_' + cfg.get('app', 'version')
                os.symlink('./resource', resdir)
        explorer('publish')
    else:
        if RepDindex:
            pdindex()
        builddebug(RepDindex)
    cfgdb['bver'] = version

## 模版
TPL_INDEX_DEBUG="""
<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <title>${APPNAME}</title>
    <meta name="viewport"
          content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"/>
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="screen-orientation" content="${APPORI}"/>
    <meta name="x5-orientation" content="${APPORI}"/>
    <meta name="full-screen" content="true"/>
    <meta name="x5-fullscreen" content="true"/>
    <meta name="360-fullscreen" content="true"/>
    <meta name="renderer" content="webkit"/>
    <meta name="browsermode" content="application"/>
    <meta name="x5-page-mode" content="app"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <app content="${APPCONTENT}">
    </app>
    <style>
        html, body {
            -ms-touch-action:none;
            padding:0;
            border:0;
            margin:0;
            height:100%;
            background:${BACKGROUNDCOLOR}
        }
        #launchDiv {
            position:absolute;
            left:0;
            top:0;
            text-align:center;
            width:100%;
            height:100%;
            background:url(${BACKGROUND}) top center no-repeat;
            background-size:auto 100%;
        }
    </style>
    ${APPSTYLE}
    <!-- 小伙伴SDK -->
    <script src="http://d.hgame.com/loadsdk?v=2"></script>
</head>
<body>
    <div id="launchDiv">        
    ${APPLAUNCH}
    </div>
    ${APPSCRIPT}
    <div style="margin:auto;width:100%;height:100%;" class="egret-player"
         data-entry-class="Main"
         data-orientation="auto"
         data-scale-mode="showAll"
         data-multi-fingered="2"
         >
    </div>
    <!-- debug信息 -->
    <script src="src/app/~debug.js"></script>
    <!-- dev工具 -->
    <script src="tools/devtools/devtools.js" type="text/javascript"></script>
    <!-- egret要求 -->
    <!--modules_files_start-->
    <!--modules_files_end-->
    <!--other_libs_files_start-->
    <!--other_libs_files_end-->
    <!--game_files_start-->
    <!--game_files_end-->
    <script>
        var document_orientation = ${APPANGLE};
    	nn.loader.webstart();        
    </script>
</body>
</html>
"""

TPL_INDEX_RELEASE="""
<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <title>${APPNAME}</title>
    <meta name="viewport" 
          content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"/>
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="screen-orientation" content="${APPORI}"/>
    <meta name="x5-orientation" content="${APPORI}"/>
    <meta name="full-screen" content="true"/>
    <meta name="x5-fullscreen" content="true"/>
    <meta name="360-fullscreen" content="true"/>
    <meta name="renderer" content="webkit"/>
    <meta name="browsermode" content="application"/>
    <meta name="x5-page-mode" content="app"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <app content="${APPCONTENT}"
         icon="${APPICON}"
         name="${APPNAME}">
    </app>
    <style>
        html, body {
            -ms-touch-action:none;
            padding:0;
            border:0;
            margin:0;
            height:100%;
            background:${BACKGROUNDCOLOR}
        }
        #launchDiv {
            position:absolute;
            left:0;
            top:0;
            text-align:center;
            width:100%;
            height:100%;
            background:url(${BACKGROUND}) top center no-repeat;
            background-size:auto 100%;
        }
    </style>
    ${APPSTYLE}
    <script src="http://d.hgame.com/loadsdk?v=2"></script>
</head>
<body>
    <div id="launchDiv">
    ${APPLAUNCH}
    </div>
    ${APPSCRIPT}
    <div style="margin:auto;width:100%;height:100%;" class="egret-player"
         data-entry-class="Main"
         data-orientation="auto"
         data-scale-mode="showAll"
         data-multi-fingered="2"
         >
    </div>
    ${FILESLIST}
    <script>
        var document_orientation = ${APPANGLE};
        nn.loader.webstart();        
    </script>
</body>
</html>
"""

TPL_NATIVE_REQUIRE = """
var game_file_list = [
//----auto game_file_list start----
//----auto game_file_list end----
];
var window = this;
egret_native.setSearchPaths([""]);
egret_native.requireFiles = function () {
    for (var key in game_file_list) {
        var src = game_file_list[key];
        require(src);
    }
};
egret_native.egretInit = function () {
    egret_native.requireFiles();
    egret.TextField.default_fontFamily = "/system/fonts/DroidSansFallback.ttf";
    //egret.dom为空实现
    egret.dom = {};
    egret.dom.drawAsCanvas = function () {
    };
};
egret_native.egretStart = function () {
    var option = {
        //以下为自动修改，请勿修改
        //----auto option start----
		entryClassName: "Main",
		frameRate: 60,
		scaleMode: "showAll",
		contentWidth: 480,
		contentHeight: 800,
		showPaintRect: false,
		showFPS: false,
		fpsStyles: "",
		showLog: false,
		logFilter: "",
		maxTouches: 2,
		textureScaleFactor: 1
		//----auto option end----
    };
    egret.native.NativePlayer.option = option;
    egret.runEgret();
    egret_native.Label.createLabel(egret.TextField.default_fontFamily, 20, "", 0);
    egret_native.EGTView.preSetOffScreenBufferEnable(true);
};
"""

def check_ebnf():
    try:
        import pyparsing
    except Exception as err:
        print('请先使用 sudo pip install pyparsing 安装 pyparsing 模块')
        sys.exit(0)

# 编译API接口
def buildapi(file):
    check_ebnf()
    mdl = SprModel()
    mdl.load(file)
    open('Api.dsl', 'w').write(mdl.output_dsl())
    open('Api.ts', 'w').write('module app.api {\n\n' + mdl.output_ts() + '\n}\n')

def log(msg):
    print(msg)

class SprModel:
    lxMain = None
    def __init__(self):
        self.subs = [] # 子文件
        self.segments = [] # 所有的数据段

        if SprModel.lxMain == None:
            import pyparsing
            SkipTo = pyparsing.SkipTo
            Word = pyparsing.Word
            Literal = pyparsing.Literal
            LineEnd = pyparsing.LineEnd
            OneOrMore = pyparsing.OneOrMore
            ZeroOrMore = pyparsing.ZeroOrMore
            Group = pyparsing.Group
            QuotedString = pyparsing.QuotedString
            Suppress = pyparsing.Suppress
            Optional = pyparsing.Optional
            alphanums = pyparsing.alphanums
            nums = pyparsing.nums
            lineEnd = pyparsing.lineEnd

            lxComment = '//' + SkipTo(lineEnd)
            lxVariable = Word(alphanums + '_')
            lxPackage = 'package' + lxVariable + Suppress(';')
            lxImport = 'import' + QuotedString("\"") + Suppress(';')
            lxOption = 'option' + SkipTo(lineEnd)
            lxRestrict = Literal('required') | Literal('optional') | Literal('repeated')
            lxType = Word(alphanums)
            lxEnumField = lxVariable + Suppress('=') + Word(nums) + Suppress(';');
            lxEnum = 'enum' + Word(alphanums) + Suppress('{') + Group(ZeroOrMore(Group(lxEnumField))) + Suppress('}')
            lxMessageField = lxRestrict + lxType + lxVariable + Suppress('=') + Word(nums) + Suppress(SkipTo(';', True))
            lxMessage = 'message' + Word(alphanums) + Suppress('{') + Group(ZeroOrMore(Group(lxMessageField))) + Suppress('}')            
            lxSegment = Suppress(lxComment) | lxPackage | lxImport | lxEnum | Suppress(lxOption) | lxMessage
            SprModel.lxMain = ZeroOrMore(Group(lxSegment))        
        
    def load(self, file):
        if os.path.isfile(file) == False:
            print('警告: ' + file + ' 文件不存在')
            return
        d = ''.join(open(file).readlines())
        self.segments = SprModel.lxMain.parseString(d)
        for segment in self.segments:
            if len(segment) == 0:
                continue
            cmd = segment[0]
            # 加载其他
            if (cmd == 'import'):
                mdl = SprModel()
                mdl.load(segment[1])
                self.subs.append(mdl)

    # 搜集所有的类对象
    def all_class(self):
        ret = []
        for sub in self.subs:
            t = sub.all_class()
            ret.extend(t)
        for segment in self.segments:
            if len(segment) == 0:
                continue
            if segment[0] == 'message':
                ret.append(segment[1])
        return ret

    # 导出框架可用的api描述文件
    def output_dsl(self):
        buf = []
        # 先导出外链
        for sub in self.subs:
            buf.append(sub.output_dsl())
        for segment in self.segments:
            if len(segment) == 0:
                continue
            cmd = segment[0]
            if cmd == 'package':
                buf.append('package ' + segment[1] + ';')
            elif cmd == 'message':
                tmp = 'message ' + segment[1]
                flds = []
                for fld in segment[2]:
                    flds.append(fld[0] + ' ' + fld[1] + ' ' + fld[2] + '=' + fld[3] + ';')
                tmp += '{\n' + '\n'.join(flds) + '\n}'
                buf.append(tmp)
        return '\n'.join(buf)

    # 导出框架可用的api代码文件
    def output_ts(self, classes = None):
        if classes == None:
            classes = self.all_class()
        buf = []        
        # 先输出所有的enum
        for segment in self.segments:
            if len(segment) == 0:
                continue
            cmd = segment[0]
            if cmd == 'enum':
                tmp = 'export enum {api} {{\n'.format(api=segment[1])
                for fld in segment[2]:
                    val = '\t{name} = {value},\n'
                    tmp += val.format(name=fld[0], value=fld[1])
                tmp += '}\n'
                buf.append(tmp)
        # 输出其他文件，以使类顺序可用
        for sub in self.subs:
            buf.append(sub.output_ts(classes))
        # 输出自己
        for segment in self.segments:
            if len(segment) == 0:
                continue
            cmd = segment[0]
            if cmd == 'message':
                api = cls = segment[1]
                if api.endswith('Req') or api.endswith('Rsp') or api.endswith('Ntf'):
                    cls = cls[:-3]
                if api.endswith('Req'):
                    tmp = 'export class {api}\nextends SocketBase\n{{\n\
\tstatic Command = Cmd.{api}Id;\n\n\
\tconstructor() {{\n\t\tsuper();\n\t\tthis.name = "{api}";\n\t\tthis.dname = "{cls}Rsp";\n\t}}\
\n\n'.format(api=api, cls=cls)
                    for fld in segment[2]:
                        prop = '\
\tset {name}(v:{type}) {{\n\t\tthis.params["{name}"] = v;\n\t}}\n\
\tget {name}():{type} {{\n\t\treturn this.params["{name}"];\n\t}}\n\n'
                        tmp += prop.format(name=fld[2], type=SprModel.ts_type(fld[1]))
                    tmp += '\tdata = new {cls}Rsp();\n\n'.format(api=api, cls=cls)
                    tmp += '}\n'
                    buf.append(tmp)
                elif api.endswith('Rsp'):
                    tmp = 'export class {api}\n{{\n\
\tstatic Command = Cmd.{api}Id;\
\n\n'.format(api=api)
                    for fld in segment[2]:
                        prop = '\t_{name}:{type};\n\
\tset {name}(v:{type}) {{\n\t\tthis._{name} = v;\n\t}}\n\
\tget {name}():{type} {{\n\t\treturn this._{name};\n\t}}\n\n'
                        tmp += prop.format(name=fld[2], type=SprModel.ts_type(fld[1]))
                    # 生成反序列化
                    if len(segment[2]) > 0:
                        uns = '\tprotected unserialize(rsp:any):boolean {\n\
\t\tif (rsp == null)\n\t\t\treturn true;\n';
                        for fld in segment[2]:
                            prop = '\t\tthis.{name} = rsp.{name};\n'.format(name=fld[2]);
                            uns += prop
                        uns += '\t}\n\n'
                        tmp += uns
                    tmp += '}\n'
                    buf.append(tmp)
                elif api.endswith('Ntf'):
                    tmp = 'export class {api}\nextends SocketBase\n{{\n\
\tstatic Command = Cmd.{api}Id;\n\n\
\tconstructor() {{\n\t\tsuper();\n\t\tthis.name = "{api}";\n\t}}\
\n\n'.format(api=api, cls=cls)
                    for fld in segment[2]:
                        prop = '\t_{name}:any{impl};\n\
\tset {name}(v:{type}) {{\n\t\tthis._{name} = v;\n\t}}\n\
\tget {name}():{type} {{\n\t\treturn this._{name};\n\t}}\n\n'
                        impl = ''
                        if fld[1] in classes:
                            impl = ' = new {type}()'.format(type=fld[1]);
                        tmp += prop.format(name=fld[2], type=SprModel.ts_type(fld[1]), impl=impl)
                    # 生成反序列化
                    if len(segment[2]) > 0:
                        uns = '\tprotected unserialize(rsp:any):boolean {\n\
\t\tif (rsp == null)\n\t\t\treturn true;\n';
                        for fld in segment[2]:
                            if fld[1] in classes:
                                prop = '\t\tthis._{name}.unserialize(rsp.{name});\n'.format(name=fld[2])
                            else:
                                prop = '\t\tthis.{name} = rsp.{name};\n'.format(name=fld[2])
                            uns += prop
                        uns += '\t}\n\n'
                        tmp += uns
                    tmp += '}\n'
                    buf.append(tmp)
                else:
                    tmp = 'export class {api}\n{{\n'.format(api=api)
                    for fld in segment[2]:
                        prop = '\t_{name}:{type};\n\
\tset {name}(v:{type}) {{\n\t\tthis._{name} = v;\n\t}}\n\
\tget {name}():{type} {{\n\t\treturn this._{name};\n\t}}\n\n'
                        tmp += prop.format(name=fld[2], type=SprModel.ts_type(fld[1]))
                    # 生成反序列化
                    if len(segment[2]) > 0:
                        uns = '\tprotected unserialize(rsp:any):boolean {\n\
\t\tif (rsp == null)\n\t\t\treturn true;\n';
                        for fld in segment[2]:
                            if fld[1] in classes:
                                prop = '\t\tthis._{name}.unserialize(rsp.{name});\n'.format(name=fld[2])
                            else:
                                prop = '\t\tthis.{name} = rsp.{name};\n'.format(name=fld[2])
                            uns += prop
                        uns += '\t}\n\n'
                        tmp += uns
                    tmp += '}\n'
                    buf.append(tmp)
        return '\n'.join(buf)

    # 类型转换
    @staticmethod
    def ts_type(ptp):
        if ptp in ['int32', 'int64', 'float', 'double']:
            return 'number'
        return ptp

# 判断是否符合一组re的判定
def ismatchs(str, rexs, non=False):
    if rexs == None:
        return non
    for be in rexs:
        bl = len(be.findall(str))
        if bl:
            return True
    return False

# 列出文件夹下所有文件，黑名单为rex
def listfiles(dir, rets = None, blacklist = None, whitelist = None, depth = -1):
    if depth == 0:
        return rets
    elif depth != -1:
        depth -= 1
    if rets == None:
        rets = []
    if os.path.isdir(dir) == False:
        return rets
    for each in os.listdir(dir):
        # 如果是文件夹则不过滤直接迭代
        path = dir + '/' + each
        if os.path.isdir(path):
            listfiles(path, rets, blacklist, whitelist, depth)
        else:
            # 黑名单过滤
            ignore = False
            if blacklist:
                for be in blacklist:
                    ignore = len(be.findall(each))
                    if ignore:
                        break        
                if ignore:
                    continue
            # 白名单过滤
            if whitelist:
                for we in whitelist:
                    ignore = not len(we.findall(each))
                    if not ignore:
                        break
                if ignore:
                    continue
            rets.append(path)
    return rets

def listdirs(dir, rets = None, blacklist = None, depth = -1):
    if depth == 0:
        return rets
    elif depth != -1:
        depth -= 1
    if rets == None:
        rets = []
    if os.path.isdir(dir) == False:
        return rets
    for each in os.listdir(dir):
        bl = False
        if blacklist:
            for be in blacklist:
                bl = len(be.findall(each))
                if bl:
                    break
        if bl:
            continue
        path = dir + '/' + each
        if os.path.isdir(path):
            rets.append(path)
            listdirs(path, rets, blacklist, depth)
    return rets

def processdirs(dir, proc, blacklist = None, depth = -1, curdir = None):
    if depth == 0:
        return
    elif depth != -1:
        depth -= 1
    if os.path.isdir(dir) == False:
        return
    for each in os.listdir(dir):
        bl = False
        if blacklist:
            for be in blacklist:
                bl = len(be.findall(each))
                if bl:
                    break
        if bl:
            continue
        path = dir + '/' + each
        if not os.path.isdir(path):
            continue
        if curdir == None:
            cd = each
        else:
            cd = curdir + '/' + each
        proc(path, cd)
        processdirs(path, proc, blacklist, depth, cd)

# 清空工程
def clean():
    if os.path.isfile('.n2~/build.db'):
        os.unlink('.n2~/build.db')
    if os.path.isdir('libs'):
        shutil.rmtree('libs')
    if os.path.isdir('bin-debug'):
        shutil.rmtree('bin-debug')
    if os.path.isdir('src/app/~tsc'):
        shutil.rmtree('src/app/~tsc')
    if os.path.isfile('.n2~/dist.db'):
        os.unlink('.n2~/dist.db')
    if os.path.isdir('.n2~/dist'):
        shutil.rmtree('.n2~/dist')
    if os.path.isfile('template/runtime/native_require.js'):
        os.unlink('template/runtime/native_require.js')

def pack(file, srcs, sumdb):
    fdiff = open('.n2~/packdiff', 'w')
    fdiff.write('Ver:\nComments:\n#\n')
    with zipfile.ZipFile(file, 'w', zipfile.ZIP_DEFLATED) as f:
        for each in srcs:
            # 计算并比较sum
            tsum = hashfile(each)
            if each in sumdb:
                dsum = sumdb[each]
            else:
                dsum = -1
            # 如果sum不一样，则代表是diff，需要提取出来
            if tsum != dsum:
                sumdb[each] = tsum
                fn = each.replace('publish/', '')
                fdiff.write(fn + ' ' + str(tsum) + '\n')
                f.write(each, 'game/' + fn)
        sumdb.close()
        fdiff.close()
        f.write('.n2~/packsums', 'package.sum')
        f.write('.n2~/packdiff', 'game/readme.txt')
        os.unlink('.n2~/packdiff')
            
# 增量打包
def dpack():
    # 每次打包均以当前日期为准(规约到日)，YYMMdd{id}.zip，id为今天打包的自增id，以当前文件夹中存在的文件为准
    # 该文件的内容为和上次打包的做比较，上次打包的文件会生成一个 package.sum 插入到zip包中，比较时均通过比较sum来判断是否改变
    fn = datetime.date.today().strftime('%y%m%d')
    srcfiles = ['publish/index.html', 'publish/main.min.js'] #全文件列表
    listfiles('publish/libs', srcfiles)
    listfiles('publish/resource', srcfiles)
    # 查找最近一次打包的信息
    zips = filter(lambda f:re.compile(r'\d+.zip').match(f), os.listdir('publish'))
    if len(zips) > 0:
        zips.sort()
        zf = zips[len(zips) - 1]
        with zipfile.ZipFile('publish/' + zf, 'r') as f:
            open('.n2~/packsums', 'w').write(f.read('package.sum'))
        if zf.startswith(fn):
            id = int(zf[-6:-4]) + 1
            fn += '{0:2}'.format(id).replace(' ', '0')
        else:
            fn += '00'
    else:
        fn += '00'
    sumdb = shelve.open('.n2~/packsums')
    pack('publish/' + fn + '.zip', srcfiles, sumdb)
    os.unlink('.n2~/packsums')
    print('生成 ' + 'publish/' + fn + '.zip')

# 调试服务
def wrk_find_file4clazz(clazz):
    findstr = "registerClass(" + clazz
    res = subprocess.getstatusoutput('grep -r "' + findstr + '" bin-debug')[1]
    fp = re.compile('^bin-debug/([a-zA-Z0-9_/]+).js:.+$').findall(res)
    if len(fp) == 0:
        return None    
    return fp[0]

# 获得类的源码
lxWrkTs = None
def wrk_ts_parser():
    global lxWrkTs
    if lxWrkTs == None:
        import pyparsing
        SkipTo = pyparsing.SkipTo
        Word = pyparsing.Word
        Literal = pyparsing.Literal
        LineEnd = pyparsing.LineEnd
        OneOrMore = pyparsing.OneOrMore
        ZeroOrMore = pyparsing.ZeroOrMore
        Group = pyparsing.Group
        QuotedString = pyparsing.QuotedString
        Suppress = pyparsing.Suppress
        Optional = pyparsing.Optional
        alphanums = pyparsing.alphanums
        nums = pyparsing.nums
        lineEnd = pyparsing.lineEnd
        Forward = pyparsing.Forward
        Empty = pyparsing.Empty
        oneOf = pyparsing.oneOf
        OnlyOnce = pyparsing.OnlyOnce

        # 预定义
        lxType = Forward()
        lxArgus = Forward()
        lxFunction = Forward()
        lxStatement = Forward()
        lxValue = Forward()
        lxValues = Optional(lxValue) + ZeroOrMore(',' + lxValue)
        lxStatements = ZeroOrMore(Group(lxStatement))
        lxLambda = Forward()
        lxNew = Forward()
        lxBody = '{' + lxStatements + '}'
        lxSelf = Forward()

        # 实现
        lxTpl = '<' + Word(alphanums + '_.') + '>'
        lxName = Optional(lxTpl) + Word(alphanums + '_$.') + Optional('[' + lxValue + ']') + Optional(lxTpl)
        lxRestrict = Optional(oneOf('private public protected'))
        lxInvoke = lxName + '(' + lxValues + ')'
        lxArray = '[' + lxValues + ']'
        lxOneValue = lxLambda | lxNew | lxInvoke | lxArray | lxName | QuotedString("'", unquoteResults=False) | QuotedString('"', unquoteResults=False) | lxSelf
        lxValue <<= lxOneValue + ZeroOrMore(oneOf('+ - * /') + lxOneValue)
        lxNew <<= 'new' + lxName + '(' + lxValues + ')'
        lxExtends = 'extends' + lxName
        lxImplement = 'implements' + lxName
        lxLambdaDef = '(' + lxArgus + ')' + '=>' + lxType
        lxLambda <<= '(' + lxArgus + ')' + Optional(':' + lxType) + '=>' + lxBody
        lxType <<= (lxName | lxLambdaDef) + Optional('[]')
        lxArgu = lxName + Optional('?') + Optional(':' + lxType + Optional('|' + lxType))
        lxArgus <<= Optional(lxArgu) + ZeroOrMore(',' + lxArgu)
        lxParam = lxArgu + Optional('=' + lxValue)
        lxParams = Optional(lxParam) + ZeroOrMore(',' + lxParam)
        lxDeclare = Word('declare') + Word('var') + lxArgu + ';'
        lxFunction <<= lxRestrict + Optional(oneOf('get set')) + lxName + '(' + lxParams + ')' + Optional(':' + lxType) + lxBody
        lxEqu = lxValue + Word('=!<>.+-*/') + lxValue
        lxAssign = Optional((Optional('export') + 'var') | Word('static')) + lxArgu + Optional(Word('=!<>.+-*/') + lxValue)
        lxProperty = lxRestrict + lxAssign + Optional(';')
        lxSubstatement = lxEqu | lxValue
        lxSubstatements = lxSubstatement + ZeroOrMore(';' + lxSubstatement)
        lxSelf <<= '(' + lxSubstatement + ')' + Optional(lxValue)
        lxReturn = 'return' + lxSubstatement + ';'
        lxIf = Word('if') + '(' + lxSubstatement + ')' + (lxStatement | lxBody)
        lxFor = Word('for') + '(' + lxSubstatements + ')' + (lxStatement | lxBody)
        lxCase = ((Word('case') + lxName) | Word('default')) + ':' + Optional(lxBody) + Word('break') + ';';
        lxSwitch = Word('switch') + '(' + lxSubstatement + ')' + Empty() + '{' + OneOrMore(lxCase) + '}'
        lxStatement <<= lxIf | lxFor | lxSwitch | lxDeclare | (lxSubstatement + ';') | (lxAssign + ';' | lxReturn)
        lxClass = Optional('export') + 'class' + lxName + Optional(lxExtends) + ZeroOrMore(lxImplement) + '{' + ZeroOrMore(Group(lxFunction | lxProperty)) + '}'
        lxContent = Group(lxClass | lxStatement)
        lxModule = 'module' + lxName + '{' + ZeroOrMore(lxContent) + '}'
        lxWrkTs = ZeroOrMore(Group(lxModule) | Group(lxContent)) 
        lxComment = '//' + SkipTo(lineEnd)
        lxComments = QuotedString('/*', endQuoteChar='*/')
        lxWrkTs.ignore(lxComment)
        lxWrkTs.ignore(lxComments)
    return lxWrkTs

def wrk_parse_tsfile(file):
    fs = readfile(file)
    return wrk_ts_parser().parseString(fs, parseAll=True)

def wrk_fetch_clazz_source(clazz, file):
    file = readfile('src/' + file + '.ts')
    segments = wrk_ts_parser().parseString(file)
    print(segments)

# ------------------------------- 自动合并图片 ---------------------------------
PATTERN_FILENAME_EXT = re.compile('(.+)\.(.+)')
            
def automergeimages(dir, name):
    name = name.replace('/', '_').lower()
    from PIL import Image
    files = []
    for ef in os.listdir(dir):
        files += PATTERN_FILENAME_EXT.findall(ef)
    ignores = []
    for ef in files:        
        ext = ef[1]
        if ext == 'fnt':
            ignores.append(ef)
        elif ext == 'json':
            ignores.append(ef)
        elif ext == 'jpg':
            ignores.append(ef)
    for ef in ignores:
        nm = ef[0]
        ext = ef[1]
        if ext == 'fnt':            
            try:
                files.remove(ef)
                files.remove((nm, 'png'))
                files.remove((nm, 'tmf'))
            except:
                pass
        elif ext == 'json':
            try:
                files.remove(ef)
                files.remove((nm, 'png'))
            except:
                pass
        elif ext == 'jpg':
            files.remove(ef)
    images = []
    for ef in files:
        path = dir + '/' + ef[0] + '.' + ef[1]
        img = Image.open(path)
        if img == None:
            print('打开图像 ' + path + ' 失败')
            continue
        bbx = img.getbbox()
        size = img.size        
        if bbx == None:
            print("图片的bbx为空，使用整张图片 " + path)
            bbx = (0, 0, size[0], size[1])
        else:
            img = img.crop(bbx)
        images.append({
            'name': ef[0],
            'path': path,
            'frame':None,
            'origin':{'offx':bbx[0], 'offy':bbx[1], 'w':size[0], 'h':size[1]},
            'img':img
        })
    images = sorted(images, cmp=mergesort)
    if len(images) == 0: #不处理空的组
        return
    workid = 0
    while True:
        work = {'work':Image.new('RGBA', (2048, 2048), (0, 0, 0, 0)),
                'result':[]}
        res = mergeImages(work, images, (0, 0, 2048, 2048))
        png = work['work']        
        png.crop(png.getbbox()).save(dir + '/' + name + '_automerged_' + str(workid) + '.png')
        frmobjs = {}
        for e in work['result']:
            frame = e['frame']
            origin = e['origin']
            frmobjs[e['name']] = {
                'x':frame['x'], 'y':frame['y'], 'w':frame['w'], 'h':frame['h'],
                'offX':origin['offx'], 'offY':origin['offy'],
                'sourceW':origin['w'], 'sourceH':origin['h']
            }
            # 删除对应的图片，这个地方的脚本和 tools/mergeimgs 不同
            os.unlink(e['path'])
        jsobj = {'file':name + "_automerged_" + str(workid) + ".png",
                 'frames':frmobjs}
        open(dir + '/' + name + '_automerged_' + str(workid) + ".json", 'w').write(json.dumps(jsobj))
        workid += 1
        if res == True:
            break

def mergesort(l, r):
    if l['img'] == None:
        return 0
    if r['img'] == None:
        return 0
    lsz = l['img'].size
    rsz = r['img'].size
    return rsz[1] - lsz[1]

def mergeImages(work, images, rc):
    if len(images) == 0:
        return True
    image = None
    for e in images:        
        sz = e['img'].size
        if rc[3] < sz[1]:
            continue
        if rc[2] < sz[0]:
            continue
        image = e
        break
    if image == None:
        return False
    images.remove(image)
    img = image['img']    
    sz = img.size
    work['work'].paste(img, (rc[0], rc[1], (rc[0] + sz[0]), rc[1] + sz[1]))
    image['frame'] = {'x':rc[0], 'y':rc[1], 'w':sz[0], 'h':sz[1]}
    work['result'].append(image)
    if mergeImages(work, images, (rc[0] + sz[0], rc[1], rc[2] - sz[0], sz[1])):
        return True
    return mergeImages(work, images, (rc[0], rc[1] + sz[1], rc[2], rc[3] - sz[1]))    
            
# ------------------------------- 开发服务 -------------------------------------
WSWRK_DEVELOPER = "::wswrk::developer"
def wswrk_developer(m):
    method = m['method']
    argus = m['fields']
    if method == '::file::dialog::save':
        m['path'] = subprocess.getoutput('python .n2~/file_dlg_save.py ')        
    elif method == '::file::dialog::open':        
        src = subprocess.getoutput('python .n2~/file_dlg_open.py')
        dst = src
        # 需要将文件copy到本地，不然会被chrome阻止访问
        if src != None:
            dst = '.n2~/developer/' + os.path.basename(src)
            shutil.copyfile(src, dst)            
        m['path'] = dst
    elif method == '::file::dialog::dir':
        m['path'] = subprocess.getoutput('python .n2~/file_dlg_dir.py')
    elif method == '::fs::mkdir':
        argus = m['fields']
        p = argus['p']
        path = argus['path']
        if not os.path.isdir(path):
            if p:
                os.makedirs(path)
            else:
                os.mkdir(path)
    elif method == '::image::open':
        file = argus['file']
        if os.path.isfile(file):
            m['hdl'] = file
    elif method == '::image::save':
        hdl = argus['hdl']
        to = argus['file']
        shutil.copyfile(hdl, to)
    elif method == '::image::scale':
        hdl = argus['hdl']
        x = argus['x']
        y = arugs['y']
        from PIL import Image
        ori = Image.open(hdl)
        w,h = ori.size
        w *= x
        h *= y
        res = ori.resize(w, h)
        to = '.n2~/developer/' + tempfilename() + os.path.basename(hdl)
        res.save(to)
        m['hdl'] = to
    elif method == '::image::subimage':
        hdl = argus['hdl']
        rect = argus['rect']
        from PIL import Image
        ori = Image.open(hdl)
        res = ori.crop((int(rect['x']), int(rect['y']), int(rect['x']) + int(rect['w']), int(rect['y']) + int(rect['h'])))
        to = '.n2~/developer/' + tempfilename() + os.path.basename(hdl)
        res.save(to)
        m['hdl'] = to
    return True

# ------------------------------- 主脚本执行 -----------------------------------
if __name__=="__main__":
    cfgdb = shelve.open('.n2~/build.db')    
    main()
    cfgdb.close()
    
